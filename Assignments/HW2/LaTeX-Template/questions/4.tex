\subsectionaddtolist{آ}{


محاسبه پنجره لازم برای پر کردن لینک:
\[
\text{پنجره لازم } = 30 \times 10^6 \times 0.3 = 9 \times 10^6 \, \text{بیت} \longrightarrow \frac{9 \times 10^6}{12,000} = 750 \, \text{سگمنت}
\]


زمان رسیدن به حداکثر پنجره:

\[
\text{زمان لازم} = (750 - 1) \times 0.3 = 224.7 \, \text{ثانیه}
\]

محاسبه میانگین Throughput

\[
\text{میانگین اندازه پنجره} = \frac{750}{2} = 375 \, \text{سگمنت}
\]

\[
\text{Throughput} = \frac{375 \times 12,000}{0.3} = 15 \, \text{Mbps}
\]

}

\subsectionaddtolist{ب}{
	

هنگامی که هاست A مشغول ارسال داده به هاست B است و در زمان \( t_1 \) دیگر داده‌ای برای ارسال ندارد، ارتباط وارد Idle می‌شود. در این شرایط دو حالت کلی وجود دارد:

\begin{itemize}
    \item اگر مدت بیکاری کمتر از مقدار{RTO (Retransmission-Timeout)} باشد، معمولاً اندازه پنجره حفظ شده و ارسال با همان پارامترهای قبلی ادامه می‌یابد.
    
    \item اگر مدت بیکاری طولانی باشد و از {RTO} عبور کند، بهتر است اندازه پنجره (\texttt{cwnd}) به مقدار اولیه کاهش یابد و کنترل ازدحام مجدداً از ابتدا آغاز شود، زیرا وضعیت شبکه ممکن است تغییر کرده باشد.
\end{itemize}

پس 
اگر وقفه طولانی باشد، بهتر است کنترل ازدحام را از ابتدا شروع کنیم.


}

\subsectionaddtolist{ج}{
	
وقتی پنجره به 75 درصد مقدار قبلی کاهش می‌یابد:
	
\textbf{TCP-Reno}

به‌صورت سنتی در هنگام congestion-loss ، پنجره را نصف می‌کند.
حالا اگر به‌جای نصف، فقط تا 75 درصد کاهش یابد، پس از congestion-loss افت سرعت کمتر می‌شود.
بعد از کاهش، دوباره با روند خطی رشد می‌کند.

\textbf{TCP-CUBIC}

به‌صورت پیش‌فرض در congestion-loss ، مقدار کاهشش توسط پارامتر beta تنظیم می‌شود.
اگر این مقدار به $0.75$ تنظیم شود، افت آن کمتر می‌شود.
بعد از افت، چون افت کمتر است، قسمت منحنی پایین‌تر، سریع‌تر طی می‌شود.

\pagebreak

وقتی پنجره دو برابر شود:

\textbf{TCP-Reno}

پس از congestion-loss ، ناگهان نرخ ارسال بسیار افزایش پیدا می‌کند (غیرمعمول و منجر به congestion شدید).
احتمالا دوباره congestion و packet-loss شدیدتری رخ می‌دهد.

\textbf{TCP-CUBIC}

اگر پس از congestion-loss ، به‌جای کاهش، دو برابر شود:
بلافاصله وارد ناحیه‌ای با
$W > W_{MAX}$
خواهد شد.
سریعا congestion جدید و packet loss رخ می‌دهد.
پس الگوریتم مجبور می‌شود دوباره شدیدتر افت کند.
}

